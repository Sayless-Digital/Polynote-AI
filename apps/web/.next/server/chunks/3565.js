"use strict";exports.id=3565,exports.ids=[3565],exports.modules={55946:(a,b,c)=>{c.r(b),c.d(b,{render:()=>E});var d=c(27160);c(37971);var e=c(59189),f=c(39123);c(59685),c(59876),c(53092);var g=c(3927),h=c(83939),i=c(7551),j=c(17518),k=c(72487),l=c(13532);function m(a){var b,c,d={options:{directed:a.isDirected(),multigraph:a.isMultigraph(),compound:a.isCompound()},nodes:(b=a,l.A(b.nodes(),function(a){var c=b.node(a),d=b.parent(a),e={v:a};return j.A(c)||(e.value=c),j.A(d)||(e.parent=d),e})),edges:(c=a,l.A(c.edges(),function(a){var b=c.edge(a),d={v:a.v,w:a.w};return j.A(a.name)||(d.name=a.name),j.A(b)||(d.value=b),d}))};return j.A(a.graph())||(d.value=k.A(a.graph())),d}c(52473);var n=c(35456),o=new Map,p=new Map,q=new Map,r=(0,h.K2)(()=>{p.clear(),q.clear(),o.clear()},"clear"),s=(0,h.K2)((a,b)=>{let c=p.get(b)||[];return h.Rm.trace("In isDescendant",b," ",a," = ",c.includes(a)),c.includes(a)},"isDescendant"),t=(0,h.K2)((a,b)=>{let c=p.get(b)||[];return h.Rm.info("Descendants of ",b," is ",c),h.Rm.info("Edge is ",a),a.v!==b&&a.w!==b&&(c?c.includes(a.v)||s(a.v,b)||s(a.w,b)||c.includes(a.w):(h.Rm.debug("Tilt, ",b,",not in descendants"),!1))},"edgeInCluster"),u=(0,h.K2)((a,b,c,d)=>{h.Rm.warn("Copying children of ",a,"root",d,"data",b.node(a),d);let e=b.children(a)||[];a!==d&&e.push(a),h.Rm.warn("Copying (nodes) clusterId",a,"nodes",e),e.forEach(e=>{if(b.children(e).length>0)u(e,b,c,d);else{let f=b.node(e);h.Rm.info("cp ",e," to ",d," with parent ",a),c.setNode(e,f),d!==b.parent(e)&&(h.Rm.warn("Setting parent",e,b.parent(e)),c.setParent(e,b.parent(e))),a!==d&&e!==a?(h.Rm.debug("Setting parent",e,a),c.setParent(e,a)):(h.Rm.info("In copy ",a,"root",d,"data",b.node(a),d),h.Rm.debug("Not Setting parent for node=",e,"cluster!==rootId",a!==d,"node!==clusterId",e!==a));let g=b.edges(e);h.Rm.debug("Copying Edges",g),g.forEach(e=>{h.Rm.info("Edge",e);let f=b.edge(e.v,e.w,e.name);h.Rm.info("Edge data",f,d);try{t(e,d)?(h.Rm.info("Copying as ",e.v,e.w,f,e.name),c.setEdge(e.v,e.w,f,e.name),h.Rm.info("newGraph edges ",c.edges(),c.edge(c.edges()[0]))):h.Rm.info("Skipping copy of edge ",e.v,"--\x3e",e.w," rootId: ",d," clusterId:",a)}catch(a){h.Rm.error(a)}})}h.Rm.debug("Removing node",e),b.removeNode(e)})},"copy"),v=(0,h.K2)((a,b)=>{let c=b.children(a),d=[...c];for(let e of c)q.set(e,a),d=[...d,...v(e,b)];return d},"extractDescendants"),w=(0,h.K2)((a,b,c)=>{let d=a.edges().filter(a=>a.v===b||a.w===b),e=a.edges().filter(a=>a.v===c||a.w===c),f=d.map(a=>({v:a.v===b?c:a.v,w:a.w===b?b:a.w})),g=e.map(a=>({v:a.v,w:a.w}));return f.filter(a=>g.some(b=>a.v===b.v&&a.w===b.w))},"findCommonEdges"),x=(0,h.K2)((a,b,c)=>{let d,e=b.children(a);if(h.Rm.trace("Searching children of id ",a,e),e.length<1)return a;for(let a of e){let e=x(a,b,c),f=w(b,c,e);if(e)if(!(f.length>0))return e;else d=e}return d},"findNonClusterChild"),y=(0,h.K2)(a=>o.has(a)&&o.get(a).externalConnections&&o.has(a)?o.get(a).id:a,"getAnchorId"),z=(0,h.K2)((a,b)=>{if(!a||b>10)return void h.Rm.debug("Opting out, no graph ");for(let b of(h.Rm.debug("Opting in, graph "),a.nodes().forEach(function(b){a.children(b).length>0&&(h.Rm.warn("Cluster identified",b," Replacement id in edges: ",x(b,a,b)),p.set(b,v(b,a)),o.set(b,{id:x(b,a,b),clusterData:a.node(b)}))}),a.nodes().forEach(function(b){let c=a.children(b),d=a.edges();c.length>0?(h.Rm.debug("Cluster identified",b,p),d.forEach(a=>{s(a.v,b)^s(a.w,b)&&(h.Rm.warn("Edge: ",a," leaves cluster ",b),h.Rm.warn("Descendants of XXX ",b,": ",p.get(b)),o.get(b).externalConnections=!0)})):h.Rm.debug("Not a cluster ",b,p)}),o.keys())){let c=o.get(b).id,d=a.parent(c);d!==b&&o.has(d)&&!o.get(d).externalConnections&&(o.get(b).id=d)}a.edges().forEach(function(b){let c=a.edge(b);h.Rm.warn("Edge "+b.v+" -> "+b.w+": "+JSON.stringify(b)),h.Rm.warn("Edge "+b.v+" -> "+b.w+": "+JSON.stringify(a.edge(b)));let d=b.v,e=b.w;if(h.Rm.warn("Fix XXX",o,"ids:",b.v,b.w,"Translating: ",o.get(b.v)," --- ",o.get(b.w)),o.get(b.v)||o.get(b.w)){if(h.Rm.warn("Fixing and trying - removing XXX",b.v,b.w,b.name),d=y(b.v),e=y(b.w),a.removeEdge(b.v,b.w,b.name),d!==b.v){let e=a.parent(d);o.get(e).externalConnections=!0,c.fromCluster=b.v}if(e!==b.w){let d=a.parent(e);o.get(d).externalConnections=!0,c.toCluster=b.w}h.Rm.warn("Fix Replacing with XXX",d,e,b.name),a.setEdge(d,e,c,b.name)}}),h.Rm.warn("Adjusted Graph",m(a)),A(a,0),h.Rm.trace(o)},"adjustClustersAndEdges"),A=(0,h.K2)((a,b)=>{if(h.Rm.warn("extractor - ",b,m(a),a.children("D")),b>10)return void h.Rm.error("Bailing out");let c=a.nodes(),d=!1;for(let b of c){let c=a.children(b);d=d||c.length>0}if(!d)return void h.Rm.debug("Done, no node has children",a.nodes());for(let d of(h.Rm.debug("Nodes = ",c,b),c))if(h.Rm.debug("Extracting node",d,o,o.has(d)&&!o.get(d).externalConnections,!a.parent(d),a.node(d),a.children("D")," Depth ",b),o.has(d))if(!o.get(d).externalConnections&&a.children(d)&&a.children(d).length>0){h.Rm.warn("Cluster without external connections, without a parent and with children",d,b);let c="TB"===a.graph().rankdir?"LR":"TB";o.get(d)?.clusterData?.dir&&(c=o.get(d).clusterData.dir,h.Rm.warn("Fixing dir",o.get(d).clusterData.dir,c));let e=new n.T({multigraph:!0,compound:!0}).setGraph({rankdir:c,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});h.Rm.warn("Old graph before copy",m(a)),u(d,a,e,d),a.setNode(d,{clusterNode:!0,id:d,clusterData:o.get(d).clusterData,label:o.get(d).label,graph:e}),h.Rm.warn("New graph after copy node: (",d,")",m(e)),h.Rm.debug("Old graph after copy",m(a))}else h.Rm.warn("Cluster ** ",d," **not meeting the criteria !externalConnections:",!o.get(d).externalConnections," no parent: ",!a.parent(d)," children ",a.children(d)&&a.children(d).length>0,a.children("D"),b),h.Rm.debug(o);else h.Rm.debug("Not a cluster",d,b);for(let d of(c=a.nodes(),h.Rm.warn("New list of nodes",c),c)){let c=a.node(d);h.Rm.warn(" Now next level",d,c),c?.clusterNode&&A(c.graph,b+1)}},"extractor"),B=(0,h.K2)((a,b)=>{if(0===b.length)return[];let c=Object.assign([],b);return b.forEach(b=>{let d=a.children(b),e=B(a,d);c=[...c,...e]}),c},"sorter"),C=(0,h.K2)(a=>B(a,a.children()),"sortNodesByHierarchy"),D=(0,h.K2)(async(a,b,c,g,j,k)=>{h.Rm.warn("Graph in recursive render:XAX",m(b),j);let l=b.graph().rankdir;h.Rm.trace("Dir in recursive render - dir:",l);let n=a.insert("g").attr("class","root");b.nodes()?h.Rm.info("Recursive render XXX",b.nodes()):h.Rm.info("No nodes found for",b),b.edges().length>0&&h.Rm.info("Recursive edges",b.edge(b.edges()[0]));let p=n.insert("g").attr("class","clusters"),q=n.insert("g").attr("class","edgePaths"),r=n.insert("g").attr("class","edgeLabels"),s=n.insert("g").attr("class","nodes");await Promise.all(b.nodes().map(async function(a){let d=b.node(a);if(void 0!==j){let c=JSON.parse(JSON.stringify(j.clusterData));h.Rm.trace("Setting data for parent cluster XXX\n Node.id = ",a,"\n data=",c.height,"\nParent cluster",j.height),b.setNode(j.id,c),b.parent(a)||(h.Rm.trace("Setting parent",a,j.id),b.setParent(a,j.id,c))}if(h.Rm.info("(Insert) Node XXX"+a+": "+JSON.stringify(b.node(a))),d?.clusterNode){h.Rm.info("Cluster identified XBX",a,d.width,b.node(a));let{ranksep:f,nodesep:i}=b.graph();d.graph.setGraph({...d.graph.graph(),ranksep:f+25,nodesep:i});let j=await D(s,d.graph,c,g,b.node(a),k),l=j.elem;(0,e.lC)(d,l),d.diff=j.diff||0,h.Rm.info("New compound node after recursive render XAX",a,"width",d.width,"height",d.height),(0,e.U7)(l,d)}else b.children(a).length>0?(h.Rm.trace("Cluster - the non recursive path XBX",a,d.id,d,d.width,"Graph:",b),h.Rm.trace(x(d.id,b)),o.set(d.id,{id:x(d.id,b),node:d})):(h.Rm.trace("Node - the non recursive path XAX",a,s,b.node(a),l),await (0,e.on)(s,b.node(a),{config:k,dir:l}))}));let t=(0,h.K2)(async()=>{let a=b.edges().map(async function(a){let c=b.edge(a.v,a.w,a.name);h.Rm.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),h.Rm.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(b.edge(a))),h.Rm.info("Fix",o,"ids:",a.v,a.w,"Translating: ",o.get(a.v),o.get(a.w)),await (0,d.jP)(r,c)});await Promise.all(a)},"processEdges");await t(),h.Rm.info("Graph before layout:",JSON.stringify(m(b))),h.Rm.info("############################################# XXX"),h.Rm.info("###                Layout                 ### XXX"),h.Rm.info("############################################# XXX"),(0,i.Zp)(b),h.Rm.info("Graph after layout:",JSON.stringify(m(b)));let u=0,{subGraphTitleTotalMargin:v}=(0,f.O)(k);return await Promise.all(C(b).map(async function(a){let c=b.node(a);if(h.Rm.info("Position XBX => "+a+": ("+c.x,","+c.y,") width: ",c.width," height: ",c.height),c?.clusterNode)c.y+=v,h.Rm.info("A tainted cluster node XBX1",a,c.id,c.width,c.height,c.x,c.y,b.parent(a)),o.get(c.id).node=c,(0,e.U_)(c);else if(b.children(a).length>0){h.Rm.info("A pure cluster node XBX1",a,c.id,c.x,c.y,c.width,c.height,b.parent(a)),c.height+=v,b.node(c.parentId);let d=c?.padding/2||0,f=c?.labelBBox?.height||0;h.Rm.debug("OffsetY",f-d||0,"labelHeight",f,"halfPadding",d),await (0,e.U)(p,c),o.get(c.id).node=c}else{let a=b.node(c.parentId);c.y+=v/2,h.Rm.info("A regular node XBX1 - using the padding",c.id,"parent",c.parentId,c.width,c.height,c.x,c.y,"offsetY",c.offsetY,"parent",a,a?.offsetY,c),(0,e.U_)(c)}})),b.edges().forEach(function(a){let e=b.edge(a);h.Rm.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(e),e),e.points.forEach(a=>a.y+=v/2);let f=b.node(a.v);var i=b.node(a.w);let j=(0,d.Jo)(q,e,o,c,f,i,g);(0,d.T_)(e,j)}),b.nodes().forEach(function(a){let c=b.node(a);h.Rm.info(a,c.type,c.diff),c.isGroup&&(u=c.diff)}),h.Rm.warn("Returning from recursive render XAX",n,u),{elem:n,diff:u}},"recursiveRender"),E=(0,h.K2)(async(a,b)=>{let c=new n.T({multigraph:!0,compound:!0}).setGraph({rankdir:a.direction,nodesep:a.config?.nodeSpacing||a.config?.flowchart?.nodeSpacing||a.nodeSpacing,ranksep:a.config?.rankSpacing||a.config?.flowchart?.rankSpacing||a.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),f=b.select("g");(0,d.g0)(f,a.markers,a.type,a.diagramId),(0,e.gh)(),(0,d.IU)(),(0,e.IU)(),r(),a.nodes.forEach(a=>{c.setNode(a.id,{...a}),a.parentId&&c.setParent(a.id,a.parentId)}),h.Rm.debug("Edges:",a.edges),a.edges.forEach(a=>{if(a.start===a.end){let b=a.start,d=b+"---"+b+"---1",e=b+"---"+b+"---2",f=c.node(b);c.setNode(d,{domId:d,id:d,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),c.setParent(d,f.parentId),c.setNode(e,{domId:e,id:e,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),c.setParent(e,f.parentId);let g=structuredClone(a),h=structuredClone(a),i=structuredClone(a);g.label="",g.arrowTypeEnd="none",g.id=b+"-cyclic-special-1",h.arrowTypeStart="none",h.arrowTypeEnd="none",h.id=b+"-cyclic-special-mid",i.label="",f.isGroup&&(g.fromCluster=b,i.toCluster=b),i.id=b+"-cyclic-special-2",i.arrowTypeStart="none",c.setEdge(b,d,g,b+"-cyclic-special-0"),c.setEdge(d,e,h,b+"-cyclic-special-1"),c.setEdge(e,b,i,b+"-cyc<lic-special-2")}else c.setEdge(a.start,a.end,{...a},a.id)}),h.Rm.warn("Graph at first:",JSON.stringify(m(c))),z(c),h.Rm.warn("Graph after XAX:",JSON.stringify(m(c)));let i=(0,g.D7)();await D(f,c,a.type,a.diagramId,void 0,i)},"render")},72487:(a,b,c)=>{c.d(b,{A:()=>e});var d=c(88699);let e=function(a){return(0,d.A)(a,4)}}};